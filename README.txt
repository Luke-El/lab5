Completing this lab was very insightful. In terms of the backend not only did we connect to our MongoDB database, but we also pulled over 100 images from 3 different photo APIs and formatted them to fit our database structure. The first API we used was Unsplash, because we had previously used it, implementing it was not difficult. The other two APIs we used were Pexels and Pixabay which had a similar structure to the API call made with Unsplash. The data we collected from the APIs were the image URLs and the alternate descriptions. The hardest part of the lab was getting the array that had all of the images to update at the right time. When we first wrote our function to pull pictures from the APIs we were only getting photos from one of our APIs despite the fact that when we used console.log() to view the array after each API was called the array was being populated. We used async on the function to fix this issue and used embedded functions to create promises for each array. Once these arrays were made we used Promise. all to concat the images to our allImages array. Once we could get the data, we 
needed a way for users to specify what data they wanted. To do this, we made a POST request that called the previously mentioned function with a category that the user input with the search bar on the front end. Once the user put in a keyword, the POST endpoint on the backend called the createImages function and pushed the images to the database. After the data was in the database, we needed a way to show users the categories in the database, so we created a GET request that got all of the categories from the database and displayed them in the navigation bar. This addition made it so every time the database updated, so was the navigation bar. The next thing we had to do was get the images to display on the front end. To do this, we used another GET request. This GET request connected to the database and utilized Math.random() to pick 12 random images from the 108 images the were collected to display 
to the front end. We also implemented a feature using DELETE. With DELETE, users could delete all of the data for a certain category from the database if they decided they are no longer interested in the topic.DELETE connected to the database and found the data associated with the word the user selected and deleted the data for it. We also used the PUT method in the lab. With PUT we enabled users to update or change categories that are currently stored in the database. PUT deletes that data for whatever topic the user selected and replaces it with the new category they want. In terms of the front end, we utilized components (navbar, image-container, and login-box) and service (app.component)  but made some changes. We made an additional navigation bar under the original one in the image-container component for the categories which the user is interested in and add into the database. We made that because the initial navbar was getting too cluttered and could not fit all of the new features and categories. The new navigation bar utilized the GET request onInit() to get all of the categories from the database and push them to an array made in the service. The array was then used by the image-container component and the navbar component. The image-container also used the GET request to display images to the user. The navbar component used the majority of our endpoints. The POST request was attached to a search bar that took in a topic from the user, which then went to the backend and called the API to gathered the data. We used a drop-down menu that used the previously mentioned array to allow users to select a topic currently in the database and call the DELETE endpoint. Finally, we used a combination of the dropdown menu and search bar to implement PUT. We used the topics array for PUT to select what needed to be deleted and a search bar to update the topic with the new data in the database. 
Overall, while in the initial stages of the lab we ran into a few bugs, this lab helped us understand how to gather data from multiple APIs and format it in a way that is useful to us and
easy to deploy into a database.

To deploy this lab cd into the lab5 folder and run node server. Then cd into the second lab5 folder and run ng build --watch.

Luke: I worked on both frontend and backend development. In terms of the backend, I made the GET request that got the categories from the database and the POST request that posted the 
images data to the database. I also wrote the createImages() function that was used to collect and format the image data gathered from the APIs. To implement the createImages() function,
I first connected to each of the APIs and used console.log() to ensure I was getting the data. Next, I converted all of the data to promises because I ran into a bug where all of the images were not being pushed into the array. I believed this is because I was using asynchronous programming. Once the promises were made, I decoded the promises and put the data in the database using the POST request. I then used the GET request to search the database for the category key and get the value to display to the frontend. For the frontend, I updated the component and service with an updated system that better suited our new features. I  used the service to my advantage when implementing the GET request that collected the categories from the database and displayed them to the user using a function in typescript to push them into an array then used a *ngFor() loop in CSS and HTML to display the information to the users. I also created a search bar that got the topic that the user typed in and sent it to the typescript which sent it to the backend using POST and collected the images using the createImages() function.

Ryan:
For my individual creativity, I try to display the pictures from the database in a simple way. When we call pictures directly from the database, each picture has its own size, and there is no space between the pictures. Besides, the image will be displayed against the edge of the web page. All the problems mentioned above will make the web page difficult to use. So I am committed to correcting these issues. In the first step, I resize all the pictures and let them have the same size. After this, I met a problem that all the images on the page display in a line that is a really bad way to present the picture because the user will spend a lot of time scrolling from left to right to find the image they want. Then I figure out that flexbox is a good way to solve this question. I used “justify-content: center; flex-wrap: wrap;” in the CSS, the image wrap based on the window size. Then I was working on the dropdown bar. The difficulty here is how to get all the category name from the database and display it in the dropdown bar. First of all, i try to use the GET method which wrote by the my teammate Luke, but that is not working properly. It load successfully but failed to display category.  The I use “getTopics = ()”  to complete the job. We wrote a ngOnInit() which will automatically run once the image-container is called, this will store all of the category name into the app-content.servicec. What I do to pull out the category is use this.appContentService.topics in ts and *ngFor in the html. One more challenge thing is that after loop through the topics, I don’t know how to write down the category name in the dropdown barm because that i am not familiar with the typescript. Then I searched on the internet, it shows that just put the content in the double brisket to make it display in the html.

For part 1, I did GET request that got the images. For this function in the server.js, it will grab the category name which type in by the user and and use the find function to find that if there is a corresponding database or not. If the database contain the category which user click, we will new a list first, then use math.randon() to pick 12 random photos from all 108 pictures in the category and save them into the new list. In this part, I met some problem. Because this is the first time that i worked with mongodb, i have no idea how to find that whether a category is in the database or not. I used SQL before, so I believe that the mongodb have same similar function. First of all, I tried to use “db.collection.find(catergory: catergory)”, but this will return the cursor to the documents match the query criteria which is not I want. Then I find another function which perfectly fit my need -- “const document = await collection.findOne({ catergory: catergory })”. In this way, it will let the database find if there are any category match the category user click. If we have only it will return document of the corresponding category, then by simple using document.image it give access to the image in that category. After this i implemented the getimage() function. Basically what getimage() do is get the category name which user click then use the GET which I wrote to get the list which contain url and alternative description of the twelve images. Then just append all the image info into the html. This part is not very hard, because we already did the similar thing in the lab4.

Moreover, I did add buttom and default button on the nav bar for the part 2. For that button, when the user click it it will automatically add 4 default category into the database. For this two, button, it use the POST request which will add the new categories into the database. For the default buttom I met the challenge that i don’t know how to use list in the typescript because it is very unfamiliar with the language which I already learned. So I search on the internet, and I found that I need to define the type before I new a list like this “let defa: string[] = ['nature', 'cat', 'dog', 'car'];”  After this addition, after we click the default it will updated the changes in the database into the frontend, which means that the new category will shows in the navbar. 





Eric: I worked on some frontend and backend. For the frontend, since I was going to be working with the replace portion of the PUT endpoint, I made a dropdown
list that the user could choose the categories from. Under the list, there was a text box to enter the new category. To the right of the input box, I put a button 
that would fire the PUT request and replace the category. For the backend, to implement the PUT request, I first created a connection to the collection in Node,
then took in both the old and new categories. First, I used await to make sure that the old category was deleted, then used the createImages() function made by
Luke to get the images of the new category and put them into the database. Lastly, to show the updated changes in the console and to make sure that Angular
updated the category list, I reassigned the list of categories and displayed them in the console as well.
